---
tags:
  - go
  - slices
  - programming
---
### Описание структуры.
**Срез(слайс)** - это структура,  которая состоит из 3-х частей: 
- указатель на исходный(резервный) массив
- длину
- емкость
```go
struct Slice {
	Array unsafe.Pointer
	Length int
	Capacity int
}
```
**Длина (length)** - это количество элементов в срезе. 

**Емкость (capacity)** - это количество элементов в исходном массиве.

### Вставка элемента, если длина равна емкости.
Если `length == capacity`, то при попытке добавить ещё один или несколько элементов в срез с помощью функции *append()* под капотом произойдет следующее:
- Go внутри себя создаст другой массив, удваивая емкость предыдущего массива(до определенного момента, затем увеличение будет лишь на 25%);
- копирует все элементы из предыдущего массива в новый;
- добавляет остальные элементы в новый массив;
- теперь срез ссылается на новый массив;
- если на старый массив больше нет ссылок, но будет удален сборщиком мусора (GC).
```go
s := make([]int, 2, 4)
s = append(s, 1, 2, 3)
fmt.Println(len(s), cap(s)) // 5 8
```
### Нарезка слайса.
При нарезке(получить подслайс) слайса, полученный слайс будет ссылаться на тот же массив, что и нарезаемый слайс, но будет иметь другую длину и емкость. Если же в новый слайс добавить больше элементов, чем емкость исходного массива, то для нового слайса будет создан новый массив, большей емкости и все элементы будут скопированы в него. 
```go
s1 := make([]int, 3, 6)  
s2 := s1[1:3]  
s2 = append(s2, 2)  
fmt.Println(s1) // [0 0 0]  
fmt.Println(s2) // [0 0 2]
```
![sliced slice](/_media/images/sliced-slice.png)
Полное выражение среза (*full slice expression*) необходимо для ограничения диапазона влияния возможных сайд-эффектов на оригинальный слайс, путем указания третьего значения - *max* и имеет следующий вид: **s[low:high:max]**; 
емкость получившегося таким образом среза будет равна *max - low*:
```go
func main() {
	s := []int{1, 2, 3}  
	f(s[:2:2])  
	fmt.Println(s)
}

func f(s []int) {  
    _ = append(s, 10)  
}
```
Если указывать емкость при нарезании слайса, то это может избавить от необходимости копирования слайса (только если это не нарезка большого среза или массива, т.к. это не решит возможную проблему утечки памяти; в таком случае нужно использовать копию среза).
### Инициализация слайса.
Слайс можно инициализировать следующими способами: 
- указать емкость, а также нулевую(необязательно) длину;
- указать только длину;
```go
// длина - 0, емкость - 3
s1 := make([]int, 0, 3)
// длина - 3, емкость - 3
s2 := make([]int, 3) // работает чуть быстрее
```
### Нулевой(nil) слайс.
Срез считается нулевым, если его значение равно **nil**. 
Срез считается пустым, если его длина равна 0. 
Каждый слайс может быть пустым, но не каждый слайс может быть нулевым, например:
```go
var s []string
fmt.Println(len(s) == 0, s == nil) // true true

s = []string(nil)
fmt.Println(len(s) == 0, s == nil) // true true

s = []string{}
fmt.Println(len(s) == 0, s == nil) // true false

s = make([]string, 0)
fmt.Println(len(s) == 0, s == nil) // true false
```
Инициализация нулевого(nil) слайса **не требует выделения памяти**
##### Способы инициализации среза в зависимости от контекста:
- **var s []string**, если нет определенности в отношении конечной длины и срез может быть пустым;
- **[]string(nil)** как синтаксический сахар для создания нулевого и пустого среза;
- **make([]string, length)**, если будущая длина известна;
- **[]string{}** - такого способа инициализации следует избегать.

Всегда стоит проверять срез на пустоту, а не на значение nil:
```go
// неправильно
s1 := []int{1, 2, 3}
fmt.Println(s1 != nil)

// правильно
s2 := []int{3, 4, 5}
fmt.Println(len(s2) != 0)
```
### Создание копии слайса.
Создать копию слайса можно при помощи встроенной функции *copy()*.
Важно понимать, что число элементов, скопированных в другой слайс, определяется минимумом между:
- длиной исходного слайса;
- длиной второго слайса.
```go
src := []int{1, 2, 3}
var dst []int
copy(dst, src)
fmt.Println(dst) // []

src = []int{3, 4, 5}
dst = make([]int, len(src))
copy(dst, src)
fmt.Println(dst) // [3 4 5]
```
Альтернативный способ создания копии слайса:
```go
src := []int{1, 2, 3}
dst := append([]int(nil), src...)
```